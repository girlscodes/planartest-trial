{"version":3,"file":"scoreCalculator.js","sourceRoot":"","sources":["../../src/scoreCalculator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @constructor\r\n * @param {Number} [opt_maxLevel] - The maximal level of the game calculated from settings.\r\n * @param {Number} [opt_actLevel] - The level of the actual game. The interval of opt_actLevel's value = [0 .. opt_maxLevel] .\r\n */\r\nexport class ScoreCalculator {\r\n    private maxLevel: number;\r\n    private actLevel: number;\r\n    private invActLevel: number;\r\n\r\n    constructor(maxLevel: number, actLevel: number) {\r\n        if (maxLevel) {\r\n            this.maxLevel = maxLevel;\r\n            this.actLevel = actLevel;\r\n\r\n            //I invert actLevel to calculate the final result\r\n            this.invActLevel = this.maxLevel - this.actLevel;\r\n        } else {\r\n            this.maxLevel = 2;\r\n            this.actLevel = 2;\r\n            this.invActLevel = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the score from the given parameters. Be sure that goodValues, actValues, acceptableValues and weights have the same size.\r\n     * GoodValues[i] contains the maximal optimal value of actValues[i]. acceptableValues[i] contains the theoretically maximal value of actValues[i]. Weights[i] is a priority value to actValues[i].\r\n     * @param {<Number>Array} goodValues - This array contains the limits of very good results. If actValues[i] < goodValues[i] the user won't get penalty for actValues[i].\r\n     * @param {<Number>Array} actValues - The results of the user in the game, e.g.: playTime, numberOfBadClicks, distanceFromTarget ...\r\n     * @param {<Number>Array} acceptableValues - This array contains the theoretically maximal values of actValues. It's possible that actValues[i] > acceptableValues[i], but it's hard to reach this limit.\r\n     * @param {<Number>Array} weights - Weight[i] represents the importance of actValues[i]. If it's possible, create weights in this way: sum(weights) = 1\r\n     * @return {Number} score - The score value.\r\n     */\r\n    public getDisplayedScore(goodValues: number[], actValues: number[], acceptableValues: number[], weights: number[]) {\r\n        if (goodValues.length != actValues.length || goodValues.length != acceptableValues.length || goodValues.length != weights.length) {\r\n            throw \"The function parameters haven't got the same size.\";\r\n        }\r\n        const maxScore = 400 + this.actLevel * 400 / this.maxLevel;\r\n        const levelDeduction = 400 / this.maxLevel * this.invActLevel;\r\n        let userPerformanceDeduction = 0;\r\n        for (let i = 0; i < goodValues.length; i++) {\r\n            if (goodValues[i] < actValues[i]) {\r\n                userPerformanceDeduction += (actValues[i] - goodValues[i]) / (acceptableValues[i] - goodValues[i]) * weights[i];\r\n            }\r\n        }\r\n\r\n        let combinedError = levelDeduction + maxScore * userPerformanceDeduction;\r\n        let score = 1000;\r\n        if (combinedError < 600) {\r\n            score -= combinedError;\r\n        } else {\r\n            score -= 600;\r\n            combinedError -= 600;\r\n            score -= combinedError / 3;\r\n            if (score < 200) {\r\n                score = 200;\r\n            }\r\n        }\r\n        return Math.round(score);\r\n    }\r\n\r\n    public getRealScore(goodValues: number[], actValues: number[], acceptableValues: number[], weights: number[]) {\r\n        if (goodValues.length != actValues.length || goodValues.length != acceptableValues.length || goodValues.length != weights.length) {\r\n            throw \"The function parameters haven't got the same size.\";\r\n        }\r\n        const maxScore = 400 + this.actLevel * 400 / this.maxLevel;\r\n        const levelDeduction = 400 / this.maxLevel * this.invActLevel;\r\n        let userPerformanceDeduction = 0;\r\n        for (let i = 0; i < goodValues.length; i++) {\r\n            userPerformanceDeduction += (actValues[i] - goodValues[i]) / (acceptableValues[i] - goodValues[i]) * weights[i];\r\n        }\r\n\r\n        let combinedError = levelDeduction + maxScore * userPerformanceDeduction;\r\n        let score = 1000;\r\n        score -= combinedError;\r\n        return Math.round(score);\r\n    }\r\n}\r\n"]}